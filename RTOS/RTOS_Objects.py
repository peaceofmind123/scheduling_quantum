import heapq
import time
import math
from threading import Thread, Lock
from numpy import random

EXP_SCALE = 2.0
class JobQueue:
    def __init__(self):
        self.queue = []
        heapq.heapify(self.queue)

    def enqueue(self, job):
        heapq.heappush(self.queue, job)

class UniprocessorTask:
    def __init__(self, wcet:int, deadline:int):
        self.wcet = wcet
        self.deadline = deadline
        self.next_arrival_time = 0 # arrival time of next job (initially that of the first job)
        self.next_job_number = 0

    def operation_step(self, current_time, job_queue: JobQueue):
        """
        One step of task operation
        :param current_time: the current global logical time
        :return:
        """
        if current_time == self.next_arrival_time:
            exec_time = math.floor(random.uniform(0,self.wcet))
            self.emit_job(current_time, exec_time, self.next_arrival_time, job_queue)
            self.next_arrival_time = self.next_arrival_time + math.floor(random.exponential(EXP_SCALE)) + self.deadline

    def emit_job(self, current_time, exec_time, arrival_time, job_queue:JobQueue):
        job = Job(self,self.next_job_number, arrival_time, exec_time)
        self.next_job_number += 1
        job_queue.enqueue(job)

class Job:
    def __init__(self, task:UniprocessorTask, job_number, arrival_time, execution_time):
        self.task = task
        self.job_number = job_number
        self.arrival_time = arrival_time
        self.execution_time = execution_time
        #TODO
        #self.priority = 1 / (self.arrival_time + self.task.deadline)


class Running:
    def __init__(self):
        self.running = None
        self.arrival_time = None
        self.execution_time = None

class TimeCounter:
    def __init__(self):
        """
        Counts time in steps of min_resolution nanoseconds
        :param min_resolution: the minimum resolution of the system clock
        """
        self.start_time = 0
        self.current_time = 0

    def get_time_elapsed(self):
        return self.current_time

    def increment_time(self):
        self.current_time += 1

class UniprocessorTaskSystem:
    def __init__(self, tasks):
        self.tasks: [UniprocessorTask] = tasks

    def operation_step(self, current_time):
        """
        Run one step of the operation of emitting jobs at current time step
        :return:
        """
        for task in self.tasks:
            task.operation_step(current_time)

class RTOS:

    def __init__(self):
        self.tasks:[UniprocessorTask] = []
        self.running = Running()

        # global shared variables and their locks
        self.running_job_expired = False
        self.running_job_expired_lock = Lock()
        self.new_job_arrived = False
        self.new_job_arrived_lock = Lock()

        self.job_queue = JobQueue()
        # start the time counter, which acts as a global logical clock
        self.time_counter = TimeCounter()

    def interrupt_mechanism(self):

        while True:
            # the interrupt handler main loop
            # check for expiration time of running job
            if self.running.arrival_time + self.running.execution_time >= self.time_counter.get_time_elapsed():
                self.interrupt_handler()

            # check for arrival of new job
            self.new_job_arrived_lock.acquire()
            if self.new_job_arrived:
                self.new_job_arrived_lock.release()
                self.interrupt_handler()

    def interrupt_handler(self):
        """
        Handle the interrupts generated by the interrupt mechanism
        :return:
        """
        pass

    def main_loop(self):
        pass

    def set_running_job_expired(self, value):
        pass

    def set_new_job_arrived(self, value):
        pass

    def set_running(self, new_running):
        pass
