import heapq
import time
import math
from threading import Thread, Lock

class UniprocessorTask:
    def __init__(self, wcet:int, deadline:int):
        self.wcet = wcet
        self.deadline = deadline


    def emit_job(self):
        pass

class Job:
    def __init__(self, task:UniprocessorTask):
        self.task = task
        self.job_number = None
        self.arrival_time = None
        self.execution_time = None

class JobQueue:
    def __init__(self):
        self.queue = []
        heapq.heapify(self.queue)


class Running:
    def __init__(self):
        self.running = None
        self.arrival_time = None
        self.execution_time = None

class TimeCounter:
    def __init__(self):
        """
        Counts time in steps of min_resolution nanoseconds
        :param min_resolution: the minimum resolution of the system clock
        """
        self.start_time = 0
        self.current_time = 0

    def get_time_elapsed(self):
        return self.current_time

    def increment_time(self):
        self.current_time += 1

class RTOS:

    def __init__(self):
        self.tasks:[UniprocessorTask] = []
        self.running = Running()

        # global shared variables and their locks
        self.running_job_expired = False
        self.running_job_expired_lock = Lock()
        self.new_job_arrived = False
        self.new_job_arrived_lock = Lock()

        self.job_queue = JobQueue()
        # start the time counter, which acts as a global logical clock
        self.time_counter = TimeCounter()

    def interrupt_mechanism(self):

        while True:
            # the interrupt handler main loop
            # check for expiration time of running job
            if self.running.arrival_time + self.running.execution_time >= self.time_counter.get_time_elapsed():
                self.interrupt_handler()

            # check for arrival of new job
            self.new_job_arrived_lock.acquire()
            if self.new_job_arrived:
                self.new_job_arrived_lock.release()
                self.interrupt_handler()

    def interrupt_handler(self):
        """
        Handle the interrupts generated by the interrupt mechanism
        :return:
        """
    def main_loop(self):
        pass

    def set_running_job_expired(self, value):
        pass

    def set_new_job_arrived(self, value):
        pass

    def set_running(self, new_running):
        pass
